<script>


  // ============================================================
  // 공용 데이터 수집 함수 - 모든 내보내기/저장 함수가 이 함수를 사용
  // ============================================================
  
  /**
   * DOM에서 타임라인 데이터를 JSON 구조로 수집
   * @param {string} name - 타임라인 이름
   * @param {Object} options - 옵션 객체
   * @param {boolean} options.includeTimeline - timeline 정보 포함 여부 (XLSX용, 기본값: false)
   * @returns {Object} JSON 형식의 타임라인 데이터
   */
  function collectTimelineDataAsJSON(name = 'Default', options = {}) {
    var includeTimeline = options.includeTimeline || false;
    
    console.log('=== collectTimelineDataAsJSON 시작 ===', { name: name, includeTimeline: includeTimeline });
    
    var jsonData = {
      metadata: {
        exportDate: new Date().toISOString(),
        name: name,
        version: "1.0",
        description: "Redmine 타임라인 데이터"
      },
      categories: []
    };
    
    // XLSX 내보내기용: options에 날짜 정보 추가 (기존 JSON 저장 형식과의 호환성을 위해 선택적)
    if (includeTimeline) {
      jsonData.options = jsonData.options || {};
      jsonData.options.startDate = "<%= start_date.strftime('%Y-%m-%d') %>";
      jsonData.options.endDate = "<%= end_date.strftime('%Y-%m-%d') %>";
    }
    
    // 데이터 캐싱을 위한 변수들
    var categoryMap = {};
    var eventMap = {};
    
    // 1단계: 모든 DOM 요소를 한 번에 가져와서 캐싱
    var allCategoryHeaders = $('.category-header').toArray();
    var allProjectItems = $('.project-item').toArray();
    var allTimelineRows = $('.timeline-row').toArray();
    
    // 2단계: 카테고리별로 데이터 맵 생성
    allCategoryHeaders.forEach(function(header) {
      var $header = $(header);
      var categoryIndex = $header.data('category-index');
      var categoryName = $header.find('.category-title').text().trim();
      
      var categoryData = {
        name: categoryName,
        index: categoryIndex,
        events: []
      };
      
      // 카테고리 커스텀 색상 정보 추가
      if (categoryColors[categoryName]) {
        categoryData.customColor = categoryColors[categoryName];
      }
      
      categoryMap[categoryIndex] = categoryData;
    });
    
    // 3단계: 이벤트별로 데이터 맵 생성
    allProjectItems.forEach(function(item) {
      var $item = $(item);
      var categoryIndex = $item.data('category-index');
      var eventName = $item.find('.project-name').text().trim();
      
      if (categoryMap[categoryIndex]) {
        var eventData = {
          name: eventName,
          schedules: []
        };
        categoryMap[categoryIndex].events.push(eventData);
        eventMap[categoryIndex + '_' + eventName] = eventData;
      }
    });
    
    // 4단계: 타임라인 행별로 스케줄 일괄 처리
    allTimelineRows.forEach(function(row) {
      var $row = $(row);
      var categoryName = $row.data('category-name');
      var eventName = $row.data('event-name');
      
      // 해당 카테고리 찾기
      var category = Object.values(categoryMap).find(function(c) { return c.name === categoryName; });
      if (!category) return;
      
      var eventKey = category.index + '_' + eventName;
      var eventData = eventMap[eventKey];
      if (!eventData) return;
      
      // 스케줄 바들을 한 번에 처리
      var scheduleBars = $row.find('.project-bar').toArray();
      scheduleBars.forEach(function(bar, barIndex) {
        var $bar = $(bar);
        var title = $bar.attr('title') || '';
        var scheduleName = $bar.attr('data-schedule-name') || $bar.find('.project-bar-text').text().trim();
        
        // 날짜 추출
        var dateMatch = title.match(/\((\d{4}-\d{2}-\d{2}) ~ (\d{4}-\d{2}-\d{2})\)/);
        
        // 이슈 추출
        var issueNumber = $bar.attr('data-issue-number') || '';
        var doneRatio = $bar.attr('data-done-ratio') || null;
        
        var scheduleData = {
          name: scheduleName,
          startDate: dateMatch ? dateMatch[1] : null,
          endDate: dateMatch ? dateMatch[2] : null,
          issue: issueNumber,
          doneRatio: doneRatio
        };
        
        // 개별 스케줄 색상
        var scheduleIndex = $bar.data('schedule-index') || barIndex;
        var scheduleKey = eventName + '_' + scheduleIndex;
        if (scheduleColors[scheduleKey]) {
          scheduleData.customColor = scheduleColors[scheduleKey];
        }
        
        eventData.schedules.push(scheduleData);
      });
    });
    
    // 5단계: 최종 데이터 구조 생성
    jsonData.categories = Object.values(categoryMap);
    
    console.log('=== collectTimelineDataAsJSON 완료 ===', jsonData);
    return jsonData;
  }
  
  // ============================================================
  // JSON 내보내기 함수 (파일 다운로드)
  // ============================================================
  
  /**
   * JSON 데이터 내보내기 함수 - 파일로 다운로드
   * 호환성: 기존 JSON 형식 유지 (timeline 미포함)
   */
  function exportTimelineData(name = 'Default') {
    console.log('JSON 데이터 내보내기 시작');
    
    // 공용 함수로 데이터 수집 (timeline 미포함 - 기존 형식 유지)
    var exportData = collectTimelineDataAsJSON(name, { includeTimeline: false });
    
    // JSON 파일로 다운로드
    var jsonString = JSON.stringify(exportData, null, 2);
    var blob = new Blob([jsonString], { type: 'application/json' });
    var url = URL.createObjectURL(blob);
    
    var downloadLink = document.createElement('a');
    downloadLink.href = url;
    downloadLink.download = 'Timeline_' + name + '_' + formatLocalDate(new Date()) + '.json';
    document.body.appendChild(downloadLink);
    downloadLink.click();
    document.body.removeChild(downloadLink);
    URL.revokeObjectURL(url);
    
    console.log('JSON 데이터 내보내기 완료');
    alert('타임라인 데이터가 JSON 파일로 내보내졌습니다.');
  }

  function importTimelineFromJSON( importData )
  {
    // 기존 데이터 삭제
      clearAllTimelineData();
      
      // 새 데이터 적용
      applyImportedData(importData);
      
      // 추가적인 레이아웃 초기화 (JSON 파일 불러오기용)
      setTimeout(function() {
        // 라인 높이 추가 업데이트
        //updateLineHeight();
        
        // 스크롤 위치 복원 (오늘 날짜 위치)
        var todayPosition = <%= today_position %>;
        var timelineContainer = $('.timeline-main');
        var containerWidth = timelineContainer.width();
        var scrollLeft = Math.max(0, todayPosition - containerWidth * 0.2);
        timelineContainer.scrollLeft(scrollLeft);
      }, 200);
  }

  // JSON 데이터 불러오기 함수
  function importTimelineData(file) {
    console.log('JSON 데이터 불러오기 시작');
    
    var reader = new FileReader();
    reader.onload = function(e) {
      try {
        var importData = JSON.parse(e.target.result);
        
        // 데이터 유효성 검사
        if (!importData.categories || !Array.isArray(importData.categories)) {
          throw new Error('올바르지 않은 JSON 형식입니다.');
        }
        
        // 확인 대화상자
        if (!confirm('현재 타임라인 데이터를 모두 삭제하고 새 데이터로 교체하시겠습니까?\n\n이 작업은 되돌릴 수 없습니다.')) {
          return;
        }
        
        importTimelineFromJSON(importData);        
        
        console.log('JSON 데이터 불러오기 완료');
        alert('타임라인 데이터가 성공적으로 불러와졌습니다.');
        
      } catch (error) {
        console.error('JSON 파싱 오류:', error);
        alert('JSON 파일을 읽는 중 오류가 발생했습니다: ' + error.message);
      }
    };
    
    reader.readAsText(file);
  }

  // ============================================================
   // XLSX 타임라인 데이터 내보내기 함수 (TxXlsxExporter 사용)
   // ============================================================
   
   /**
    * XLSX 타임라인 데이터 내보내기 함수
    * TxXlsxExporter (redmine_tx_0_base)를 사용하여 Excel 파일 생성
    */
   function exportTimelineToXlsx() {
     console.log('XLSX 타임라인 데이터 내보내기 시작');
     
     var xlsxBtn = $('#exportXlsxBtn');
     var originalText = xlsxBtn.html();
     
     try {
       // TxXlsxExporter 라이브러리 로드 확인
       if (typeof TxXlsxExporter === 'undefined') {
         throw new Error('TxXlsxExporter 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.');
       }
       
       // ExcelJS 라이브러리 로드 확인
       if (typeof ExcelJS === 'undefined') {
         throw new Error('ExcelJS 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.');
       }
       
       // 공용 함수로 데이터 수집 (timeline 포함 - XLSX용)
       var jsonData = collectTimelineDataAsJSON('timeline', { includeTimeline: true });
       
       // 데이터 유효성 확인
       if (!jsonData.categories || jsonData.categories.length === 0) {
         alert('내보낼 데이터가 없습니다. 먼저 카테고리와 이벤트를 추가해주세요.');
         return;
       }
       
       // 버튼 상태 변경
       xlsxBtn.html('<span class="json-btn-icon">⏳</span>내보내는 중...');
       xlsxBtn.prop('disabled', true);
       
       // 파일명 생성
       var fileName = 'timeline_' + formatLocalDate(new Date());
       
       // TxXlsxExporter를 사용하여 Excel 파일 생성 및 다운로드
       TxXlsxExporter.exportToXlsx(jsonData, fileName)
         .then(function() {
           console.log('✅ XLSX 타임라인 데이터 내보내기 완료');
           alert('타임라인 데이터가 Excel 파일로 내보내졌습니다.');
           
           // 버튼 상태 복원
           xlsxBtn.html(originalText);
           xlsxBtn.prop('disabled', false);
         })
         .catch(function(error) {
           console.error('XLSX 내보내기 오류:', error);
           alert('Excel 파일 내보내기 중 오류가 발생했습니다:\n\n' + error.message);
           
           // 버튼 상태 복원
           xlsxBtn.html(originalText);
           xlsxBtn.prop('disabled', false);
         });
       
     } catch (error) {
       console.error('XLSX 내보내기 초기 오류:', error);
       alert('Excel 파일 내보내기 초기화 중 오류가 발생했습니다:\n\n' + error.message);
       
       // 버튼 상태 복원
       xlsxBtn.html(originalText);
       xlsxBtn.prop('disabled', false);
     }
  }

   // PNG 로드맵 이미지 내보내기 함수
   function exportTimelineToPng() {
     console.log('PNG 로드맵 이미지 내보내기 시작');
     
     var pngBtn = $('#exportPngBtn');
     var originalText = pngBtn.html();
     
     try {
       // html2canvas 라이브러리 로드 확인
       if (typeof html2canvas === 'undefined') {
         throw new Error('html2canvas 라이브러리가 로드되지 않았습니다. 페이지를 새로고침해주세요.');
       }
       
       // 캡처할 요소 선택
       var timelineContainer = $('.timeline-container');
       
       if (timelineContainer.length === 0) {
         throw new Error('타임라인 컨테이너를 찾을 수 없습니다.');
       }
       
       // 이벤트가 있는 영역만 캡처하기 위한 계산
       var timelineElement = timelineContainer.find('.timeline-main')[0];
       var timelineBodyElement = timelineContainer.find('.timeline-body')[0];
       
       // 모든 프로젝트 바의 위치를 분석하여 실제 사용 영역 계산
       var projectBars = timelineContainer.find('.project-bar');
       var sidebarWidth = 300;
       var minLeft = Infinity;
       var maxRight = -Infinity;
       
       console.log('프로젝트 바 개수:', projectBars.length);
       
       if (projectBars.length > 0) {
         projectBars.each(function() {
           var $bar = $(this);
           // style 속성에서 직접 left 값 파싱 (더 정확함)
           var styleLeft = $bar.attr('style') || '';
           var leftMatch = styleLeft.match(/left:\s*(\d+)px/);
           var widthMatch = styleLeft.match(/width:\s*(\d+)px/);
           
           var barLeft = leftMatch ? parseInt(leftMatch[1]) : 0;
           var barWidth = widthMatch ? parseInt(widthMatch[1]) : 0;
           var barRight = barLeft + barWidth;
           
           console.log('프로젝트 바:', $bar.find('.project-bar-text').text(), 'left:', barLeft, 'width:', barWidth);
           
           minLeft = Math.min(minLeft, barLeft);
           maxRight = Math.max(maxRight, barRight);
         });
         
         // 여백 추가 (좌우 각각 2주 정도)
         var marginDays = 14;
         var marginWidth = marginDays * cellWidth;
         minLeft = Math.max(0, minLeft - marginWidth);
         maxRight = maxRight + marginWidth;
         
         console.log('이벤트 영역 - 시작:', minLeft, '끝:', maxRight);
         console.log('셀 너비:', cellWidth, '여백:', marginWidth);
         
         // 컨테이너 너비 = 사이드바 + 실제 사용하는 타임라인 영역
         var containerWidth = sidebarWidth + (maxRight - minLeft);
         
       } else {
         // 이벤트가 없는 경우 기본 6개월 정도만 표시
         var defaultWidth = 180 * cellWidth; // 약 6개월
         var containerWidth = sidebarWidth + defaultWidth;
         minLeft = 0;
         maxRight = defaultWidth;
         
         console.log('이벤트 없음 - 기본 너비 사용:', containerWidth);
       }
       
       var containerHeight = Math.max(
         timelineContainer[0].scrollHeight,
         timelineBodyElement ? timelineBodyElement.scrollHeight : 0
       );
       var maxWidth = 16000; // 최대 너비 제한 (DPI 향상으로 인한 증가)
       var maxHeight = 12000; // 최대 높이 제한 (DPI 향상으로 인한 증가)
       
       console.log('원본 크기:', containerWidth + 'x' + containerHeight);
       
       // 크기가 너무 큰 경우 스케일 조정
       var scale = 2.0; // 기본 스케일을 2.0으로 설정 (DPI 향상)
       
       if (containerWidth > maxWidth || containerHeight > maxHeight) {
         var widthScale = maxWidth / containerWidth;
         var heightScale = maxHeight / containerHeight;
         scale = Math.min(widthScale, heightScale, 1.5); // 최대 스케일 1.5로 제한 (DPI 고려)
         
         console.log('크기 제한으로 인한 스케일 조정:', scale);
       }
       
       // 예상 이미지 크기 계산
       var finalWidth = Math.floor(containerWidth * scale);
       var finalHeight = Math.floor(containerHeight * scale);
       var estimatedPixels = finalWidth * finalHeight;
       var estimatedMemoryMB = (estimatedPixels * 4) / (1024 * 1024); // RGBA 4바이트 per pixel
       
       console.log('예상 최종 크기:', finalWidth + 'x' + finalHeight);
       console.log('예상 메모리 사용량:', Math.round(estimatedMemoryMB) + 'MB');
       
       // 메모리 사용량이 너무 큰 경우 경고
       if (estimatedMemoryMB > 500) {
         if (!confirm('이미지 크기가 큽니다 (' + finalWidth + 'x' + finalHeight + ', 약 ' + Math.round(estimatedMemoryMB) + 'MB).\n\n계속 진행하시겠습니까?\n\n• 예: 그대로 진행\n• 아니오: 취소')) {
           return;
         }
       }
       
       // 버튼 상태 변경 (로딩 표시)
       pngBtn.html('<span class="json-btn-icon">⏳</span>생성중...');
       pngBtn.prop('disabled', true);
       
       console.log('타임라인 컨테이너 캡처 시작... (스케일: ' + scale + ')');
       
       // 캡처 옵션 설정 (최적화됨)
       var captureOptions = {
         useCORS: true,
         allowTaint: false, // 보안 강화
         backgroundColor: '#ffffff',
         scale: scale, // 동적으로 계산된 스케일
         width: containerWidth,
         height: containerHeight,
         scrollX: 0,
         scrollY: 0,
         logging: false,
         removeContainer: true,
         foreignObjectRendering: false, // 메모리 사용량 감소
         imageTimeout: 10000, // 타임아웃 단축
         ignoreElements: function(element) {
           // 불필요한 요소들 제외 (메모리 절약)
           if (element.classList && (
             element.classList.contains('json-controls') ||
             element.classList.contains('ui-resizable-handle') ||
             element.classList.contains('ui-draggable-helper')
           )) {
             return true;
           }
           return false;
         },
         onclone: function(clonedDoc) {
           // 복제된 문서에서 추가 스타일 적용
           var clonedContainer = clonedDoc.querySelector('.timeline-container');
           if (clonedContainer) {
             // 스크롤바 및 오버플로우 처리
             clonedContainer.style.overflow = 'visible';
             clonedContainer.style.height = 'auto';
             clonedContainer.style.maxHeight = 'none';
             clonedContainer.style.position = 'static';
             clonedContainer.style.display = 'flex'; // flex 유지
             clonedContainer.style.flexDirection = 'row'; // 가로 배치 명시
             clonedContainer.style.alignItems = 'flex-start'; // 상단 정렬
             
             // 사이드바 최적화
             var sidebar = clonedContainer.querySelector('.timeline-sidebar');
             if (sidebar) {
               sidebar.style.overflow = 'visible';
               sidebar.style.height = 'auto';
               sidebar.style.maxHeight = 'none';
               sidebar.style.display = 'block'; // flex-item으로 유지
               sidebar.style.width = '300px'; // 고정 너비 유지
               sidebar.style.minWidth = '300px'; // 최소 너비 설정
               sidebar.style.flexShrink = '0'; // 축소 방지
               
               var sidebarContent = sidebar.querySelector('.sidebar-content');
               if (sidebarContent) {
                 sidebarContent.style.overflow = 'visible';
                 sidebarContent.style.height = 'auto';
                 sidebarContent.style.maxHeight = 'none';
               }
             }
             
             // 타임라인 영역 최적화
             var timeline = clonedContainer.querySelector('.timeline-main');
             if (timeline) {
               timeline.style.overflow = 'visible'; // visible로 변경
               timeline.style.height = 'auto';
               timeline.style.maxHeight = 'none';
               timeline.style.display = 'flex'; // flex로 유지
               timeline.style.flexDirection = 'column'; // 세로 배치
               timeline.style.flex = '1'; // 남은 공간 차지
               timeline.style.minWidth = '0'; // flex 축소 허용
               timeline.style.width = (maxRight - minLeft) + 'px'; // 너비 제한
               
               // 타임라인 헤더도 최적화
               var timelineHeader = timeline.querySelector('.timeline-header');
               if (timelineHeader) {
                 timelineHeader.style.overflow = 'visible'; // visible로 변경
                 timelineHeader.style.width = 'auto';
                 timelineHeader.style.flexShrink = '0'; // 헤더 축소 방지
                 
                 // 헤더 내 월/일 헤더 크롭
                 var monthHeader = timelineHeader.querySelector('.month-header');
                 var dayHeader = timelineHeader.querySelector('.day-header');
                 
                 if (monthHeader && dayHeader) {
                   monthHeader.style.transform = 'translateX(-' + minLeft + 'px)';
                   dayHeader.style.transform = 'translateX(-' + minLeft + 'px)';
                 }
               }
             }
             
             // 타임라인 바디 최적화 - 가장 중요한 부분!
             var timelineBody = clonedContainer.querySelector('.timeline-body');
             if (timelineBody) {
               // 스크롤 영역을 완전히 확장
               timelineBody.style.overflow = 'visible'; // visible로 변경하여 내용이 보이도록
               timelineBody.style.height = 'auto';
               timelineBody.style.maxHeight = 'none';
               timelineBody.style.minHeight = 'auto';
               
               // 실제 스크롤 높이로 설정하여 모든 내용이 보이도록 함
               var originalTimelineBody = document.querySelector('.timeline-body');
               if (originalTimelineBody) {
                 var fullHeight = originalTimelineBody.scrollHeight;
                 timelineBody.style.height = fullHeight + 'px';
                 console.log('타임라인 바디 높이 설정:', fullHeight + 'px');
               }
               
               // 타임라인 바디 내 모든 요소들 크롭
               var dateGridLines = timelineBody.querySelector('.date-grid-lines');
               var todayLine = timelineBody.querySelector('.today-line');
               var timelineRows = timelineBody.querySelectorAll('.timeline-row');
               
               // 날짜 그리드 라인 크롭 - 사이드바 영역 제외
               if (dateGridLines) {
                 dateGridLines.style.transform = 'translateX(-' + minLeft + 'px)';
                 dateGridLines.style.position = 'relative';
                 dateGridLines.style.overflow = 'visible'; // 세로선이 보이도록
                 
                 // 개별 날짜 그리드 라인들 처리
                 var gridLines = dateGridLines.querySelectorAll('.date-grid-line');
                 for (var k = 0; k < gridLines.length; k++) {
                   var line = gridLines[k];
                   var lineLeft = parseInt(line.style.left) || 0;
                   // 크롭 범위 내에 있는 라인만 표시
                   if (lineLeft >= minLeft && lineLeft <= maxRight) {
                     line.style.display = 'block';
                   } else {
                     line.style.display = 'none';
                   }
                 }
               }
               
               // 오늘 표시선 크롭
               if (todayLine) {
                 var todayLeft = parseInt(todayLine.style.left) || 0;
                 if (todayLeft >= minLeft && todayLeft <= maxRight) {
                   todayLine.style.left = (todayLeft - minLeft) + 'px';
                 } else {
                   todayLine.style.display = 'none'; // 범위 밖이면 숨김
                 }
               }
               
               // 모든 타임라인 행 크롭
               for (var i = 0; i < timelineRows.length; i++) {
                 var row = timelineRows[i];
                 row.style.overflow = 'visible'; // 행별 overflow를 visible로 변경
                 
                 // 타임라인 그리드 크롭
                 var timelineGrid = row.querySelector('.timeline-grid');
                 if (timelineGrid) {
                   timelineGrid.style.transform = 'translateX(-' + minLeft + 'px)';
                   timelineGrid.style.position = 'relative';
                   timelineGrid.style.overflow = 'visible'; // 그리드 visible로 변경
                 }
                 
                 // 프로젝트 바들 위치 조정
                 var projectBars = row.querySelectorAll('.project-bar');
                 for (var j = 0; j < projectBars.length; j++) {
                   var bar = projectBars[j];
                   // style 속성에서 직접 left 값 파싱
                   var barStyle = bar.getAttribute('style') || '';
                   var barLeftMatch = barStyle.match(/left:\s*(\d+)px/);
                   var barLeft = barLeftMatch ? parseInt(barLeftMatch[1]) : 0;
                   
                   // 새로운 위치 계산
                   var newLeft = barLeft - minLeft;
                   bar.style.left = newLeft + 'px';
                   
                   console.log('프로젝트 바 위치 조정:', barLeft, '->', newLeft);
                 }
               }
             }
             
             // JSON 컨트롤 버튼들 숨기기
             var controls = clonedDoc.querySelector('.json-controls');
             if (controls) {
               controls.style.display = 'none';
             }
             
             // 불필요한 애니메이션 제거
             var allElements = clonedDoc.querySelectorAll('*');
             for (var i = 0; i < allElements.length; i++) {
               allElements[i].style.transition = 'none';
               allElements[i].style.animation = 'none';
             }
           }
           
           console.log('DOM 복제 및 스타일 적용 완료');
         }
       };
       
       // html2canvas로 캡처 실행 (비동기 처리)
       setTimeout(function() {
         html2canvas(timelineContainer[0], captureOptions).then(function(canvas) {
           try {
             console.log('캔버스 생성 완료, 크기:', canvas.width + 'x' + canvas.height);
             
             // 캔버스 크기 검증
             if (canvas.width === 0 || canvas.height === 0) {
               throw new Error('생성된 캔버스의 크기가 잘못되었습니다.');
             }
             
             var actualPixels = canvas.width * canvas.height;
             var actualMemoryMB = (actualPixels * 4) / (1024 * 1024);
             console.log('실제 메모리 사용량:', Math.round(actualMemoryMB) + 'MB');
             
             // Blob 방식으로 안전하게 이미지 생성
             canvas.toBlob(function(blob) {
               if (!blob) {
                 throw new Error('이미지 Blob 생성에 실패했습니다.');
               }
               
               console.log('Blob 생성 완료, 크기:', Math.round(blob.size / 1024) + 'KB');
               
               // 파일 다운로드
               var url = URL.createObjectURL(blob);
               var downloadLink = document.createElement('a');
               var now = new Date();
               var filename = 'timeline_' + now.getFullYear() + '-' + 
                             String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(now.getDate()).padStart(2, '0') + '_' +
                             String(now.getHours()).padStart(2, '0') + 
                             String(now.getMinutes()).padStart(2, '0') + '.png';
               
               downloadLink.href = url;
               downloadLink.download = filename;
               downloadLink.style.display = 'none';
               
               // 임시로 DOM에 추가하고 클릭하여 다운로드
               document.body.appendChild(downloadLink);
               downloadLink.click();
               
               // 정리 작업
               setTimeout(function() {
                 document.body.removeChild(downloadLink);
                 URL.revokeObjectURL(url);
               }, 100);
               
               console.log('PNG 이미지 다운로드 완료:', filename);
               alert('타임라인이 PNG 이미지로 저장되었습니다!\n\n' +
                     '파일명: ' + filename + '\n' +
                     '이미지 크기: ' + canvas.width + ' × ' + canvas.height + ' 픽셀\n' +
                     '파일 크기: ' + Math.round(blob.size / 1024) + 'KB');
               
               // 버튼 상태 복원
               pngBtn.html(originalText);
               pngBtn.prop('disabled', false);
               
             }, 'image/png', 0.9); // PNG 형식, 품질 90% (메모리 절약)
             
           } catch (downloadError) {
             console.error('PNG 처리 오류:', downloadError);
             
             // 대안: toDataURL 방식으로 재시도 (더 작은 해상도)
             try {
               console.log('대안 방식으로 재시도...');
               var smallCanvas = document.createElement('canvas');
               var ctx = smallCanvas.getContext('2d');
               
               // 크기를 절반으로 줄여서 재시도
               var targetWidth = Math.floor(canvas.width * 0.5);
               var targetHeight = Math.floor(canvas.height * 0.5);
               
               smallCanvas.width = targetWidth;
               smallCanvas.height = targetHeight;
               
               // 이미지 품질 설정
               ctx.imageSmoothingEnabled = true;
               ctx.imageSmoothingQuality = 'high';
               
               // 축소된 크기로 그리기
               ctx.drawImage(canvas, 0, 0, targetWidth, targetHeight);
               
               // 축소된 이미지를 데이터 URL로 변환
               var imageDataUrl = smallCanvas.toDataURL('image/png', 0.8);
               
               // 다운로드 링크 생성
               var downloadLink = document.createElement('a');
               var now = new Date();
               var filename = 'timeline_small_' + now.getFullYear() + '-' + 
                             String(now.getMonth() + 1).padStart(2, '0') + '-' + 
                             String(now.getDate()).padStart(2, '0') + '.png';
               
               downloadLink.href = imageDataUrl;
               downloadLink.download = filename;
               downloadLink.style.display = 'none';
               
               document.body.appendChild(downloadLink);
               downloadLink.click();
               document.body.removeChild(downloadLink);
               
               console.log('축소된 PNG 이미지 다운로드 완료:', filename);
               alert('메모리 절약을 위해 축소된 PNG 이미지가 저장되었습니다!\n\n' +
                     '파일명: ' + filename + '\n' +
                     '이미지 크기: ' + targetWidth + ' × ' + targetHeight + ' 픽셀');
               
            } catch (fallbackError) {
               console.error('대안 방식도 실패:', fallbackError);
               alert('이미지 처리 중 오류가 발생했습니다.\n\n' +
                     '원인: ' + downloadError.message + '\n\n' +
                     '해결 방법:\n' +
                     '• 브라우저 줌을 50% 이하로 줄여보세요\n' +
                     '• 일부 스케줄을 숨긴 후 다시 시도하세요\n' +
                     '• 더 작은 기간의 로드맵으로 축소해보세요');
            }
             
             // 버튼 상태 복원
             pngBtn.html(originalText);
             pngBtn.prop('disabled', false);
           }
           
         }).catch(function(canvasError) {
           console.error('캔버스 생성 오류:', canvasError);
           
           var errorMessage = '이미지 생성 중 오류가 발생했습니다.\n\n';
           
           if (canvasError.message && (canvasError.message.includes('Invalid string length') || 
                                      canvasError.message.includes('RangeError') ||
                                      canvasError.message.includes('out of memory'))) {
             errorMessage += '오류 원인: 메모리 부족 (이미지가 너무 큼)\n\n해결 방법:\n';
             errorMessage += '• 브라우저 줌을 25-50%로 줄여보세요\n';
             errorMessage += '• 타임라인을 여러 번에 나누어 스크린샷으로 캡처하세요\n';
             errorMessage += '• 일부 카테고리나 스케줄을 숨긴 후 다시 시도하세요\n';
             errorMessage += '• 더 작은 기간(3-6개월)의 로드맵으로 축소해보세요\n';
             errorMessage += '• Chrome의 시크릿 모드에서 시도해보세요\n';
             errorMessage += '• 컴퓨터 메모리가 부족한 경우 다른 프로그램을 종료하세요';
           } else if (canvasError.message && canvasError.message.includes('timeout')) {
             errorMessage += '오류 원인: 처리 시간 초과\n\n해결 방법:\n';
             errorMessage += '• 페이지를 새로고침한 후 다시 시도하세요\n';
             errorMessage += '• 복잡한 스케줄이 많은 경우 일부를 숨긴 후 시도하세요';
           } else if (canvasError.message && (canvasError.message.includes('tainted') || canvasError.message.includes('CORS'))) {
             errorMessage += '오류 원인: 외부 리소스 접근 제한\n\n해결 방법:\n';
             errorMessage += '• 페이지를 새로고침한 후 다시 시도하세요\n';
             errorMessage += '• 브라우저의 보안 설정을 확인하세요';
           } else {
             errorMessage += '오류 세부사항: ' + canvasError.message + '\n\n';
             errorMessage += '해결 방법:\n';
             errorMessage += '• 페이지를 새로고침한 후 다시 시도하세요\n';
             errorMessage += '• 다른 브라우저(Chrome, Firefox)에서 시도해보세요\n';
             errorMessage += '• 브라우저의 하드웨어 가속을 비활성화해보세요\n';
             errorMessage += '• 개발자 도구(F12)에서 자세한 오류를 확인하세요';
           }
           
           alert(errorMessage);
           
           // 버튼 상태 복원
           pngBtn.html(originalText);
           pngBtn.prop('disabled', false);
         });
       }, 100); // UI 업데이트 완료 대기
       
     } catch (error) {
       console.error('PNG 내보내기 초기 오류:', error);
       alert('PNG 이미지 내보내기 초기화 중 오류가 발생했습니다:\n\n' + error.message);
       
       // 버튼 상태 복원
       pngBtn.html(originalText);
       pngBtn.prop('disabled', false);
     }
     
   }

   // 서버에서 타임라인 데이터 불러오기 함수
  function loadTimelineFromServer( name = 'Default' ) {
    console.log('=== 서버에서 타임라인 데이터 불러오기 시작 ===');
    
    $.ajax({
      url: '<%= load_timeline_data_project_timeline_index_path(@project) %>',
      method: 'GET',
      data: { name: name },
      success: function(response) {
        console.log('✅ 서버 로드 성공:', response);
        
        if (response.success && response.data) {
          try {
            // 서버에서 받은 데이터는 이미 JSON 파일 형식
            var importData = response.data;
            
            // 데이터 유효성 검사
            if (!importData.categories || !Array.isArray(importData.categories)) {
              throw new Error('올바르지 않은 JSON 형식입니다.');
            }
            
            importTimelineFromJSON(importData);
            
            console.log('✅ 서버에서 타임라인 데이터 불러오기 완료');          
            //alert('서버에서 타임라인 데이터를 성공적으로 불러왔습니다.');
            
          } catch (error) {
            console.error('❌ 데이터 처리 오류:', error);
            alert('서버에서 받은 데이터를 처리하는 중 오류가 발생했습니다: ' + error.message);
          }
        } else {
          console.log('❌ 서버 응답에 데이터가 없음:', response);
          alert('서버에서 받은 데이터가 유효하지 않습니다.');
        }
      },
      error: function(xhr, status, error) {
        console.error('❌ 서버 로드 실패:', {
          status: xhr.status,
          statusText: xhr.statusText,
          responseText: xhr.responseText,
          error: error
        });
        alert('서버에서 데이터를 불러오는데 실패했습니다.\n\n상태: ' + xhr.status + '\n오류: ' + error);
      }
    });
  }

   // ============================================================
   // 서버에 타임라인 데이터 저장 함수 (리팩토링 버전 - 공용 함수 사용)
   // ============================================================
   
   /**
    * 서버에 타임라인 데이터 저장 함수
    * 호환성: 기존 JSON 형식 유지 (timeline 미포함)
    */
   function saveTimelineToServer(name = 'Default') {
     console.log('서버에 타임라인 데이터 저장 시작');
     
     // 확인 대화상자
     if (!confirm('현재 타임라인 데이터를 서버에 저장하시겠습니까?')) {
       return;
     }
     
     // 버튼 상태 변경 (로딩 표시)
     var saveBtn = $('#saveJsonBtn');
     var originalText = saveBtn.html();
     saveBtn.html('<span class="json-btn-icon">⏳</span>Saving...');
     saveBtn.prop('disabled', true);
     
     // 비동기 처리로 UI 블로킹 방지
     setTimeout(function() {
       try {
         // 공용 함수로 데이터 수집 (timeline 미포함 - 기존 형식 유지)
         var saveData = collectTimelineDataAsJSON(name, { includeTimeline: false });
         
         // 서버 저장용으로 설명 변경
         saveData.metadata.description = "Redmine 타임라인 데이터 - 서버 저장";
         
         console.log('전송할 데이터:', saveData);
         
         // 서버에 AJAX 요청으로 데이터 전송
         $.ajax({
           url: '<%= save_timeline_data_project_timeline_index_path(@project) %>',
           method: 'POST',
           headers: {
             'X-CSRF-Token': $('meta[name="csrf-token"]').attr('content'),
             'Content-Type': 'application/json'
           },
           data: JSON.stringify({
             timeline_data: JSON.stringify(saveData),
             name: name
           }),
           success: function(response) {
             console.log('서버 저장 성공:', response);
             alert('타임라인 데이터가 서버에 성공적으로 저장되었습니다.');
             
             // 버튼 상태 복원
             saveBtn.html(originalText);
             saveBtn.prop('disabled', false);
           },
           error: function(xhr, status, error) {
             console.error('서버 저장 실패:', {
               status: xhr.status,
               statusText: xhr.statusText,
               responseText: xhr.responseText,
               error: error
             });
             
             var errorMessage = '서버 저장에 실패했습니다.\n\n';
             if (xhr.responseText) {
               try {
                 var errorData = JSON.parse(xhr.responseText);
                 errorMessage += '오류: ' + (errorData.message || errorData.error || '알 수 없는 오류');
               } catch (e) {
                 errorMessage += '서버 응답: ' + xhr.responseText.substring(0, 200);
               }
             } else {
               errorMessage += '상태 코드: ' + xhr.status + '\n오류: ' + error;
             }
             
             // 임시 방편: 로컬 스토리지에 저장
             try {
               localStorage.setItem('timeline_backup_' + new Date().getTime(), JSON.stringify(saveData));
               errorMessage += '\n\n임시로 브라우저 로컬 스토리지에 백업되었습니다.';
             } catch (e) {
               // 로컬 스토리지 저장 실패는 무시
             }
             
             alert(errorMessage);
             
             // 버튼 상태 복원
             saveBtn.html(originalText);
             saveBtn.prop('disabled', false);
           }
         });
         
       } catch (error) {
         console.error('데이터 수집 오류:', error);
         alert('데이터 수집 중 오류가 발생했습니다:\n\n' + error.message);
         
         // 버튼 상태 복원
         saveBtn.html(originalText);
         saveBtn.prop('disabled', false);
       }
     }, 100); // UI 업데이트를 위한 짧은 지연
   }

   
</script>